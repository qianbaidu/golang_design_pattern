# golang设计模式
### 设计模式基本原则
- 1.单一职责原则(Single Responsibility Principle, SRP) ： 一个类应该只负责一项职责，不能将多个职责放到一个类中
- 2.接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口。使用多个专门的接口取代一个统一的接口
- 3.依赖倒转：高层模块不应该依赖细节。细节应该依赖抽象
- 4.里氏替换：子类中尽量不要重写父类的方法
- 5.开闭原则：对扩展开放，对修改关闭
- 6.迪米特法则：也称最少知道原则，一个类对自己依赖的类知道的越少越好。两个类如果不必彼此同行，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互
- 7.合成复用原则：尽量使用合成、聚合的方式，而非继承

### 创建型
- **单例模式**：一个类只存在一个实例 [代码](./singleton)
- **工厂模式**：
    - 简单工程模式：由一个工厂对象决定创建出哪一种产品类的实例。定义一个创建对象的类，由这个类来封装实例化对象的行为（通常由传入参数判断要创建、实例化工厂）
    - 工厂方法模式: 定义一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类（工厂实例化方法创建、实例移至子类完成）
    - 抽象工厂模式：
        - 定义一个interface用于创建相关或有依赖关系的对象簇，而无需指定具体的类，而无需指明具体的类
        - 抽象工厂模式可以将简单工厂模式和工厂方法进行整合
        - 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）
        - 将工厂抽象成两层：抽象工厂和具体实现的工厂子类。方便根据创建对象类型使用对应的工厂子类，这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展
    - [工厂模式代码](./factory)
    - [抽象工厂模式代码](./abstract_factory)

- **原型模式 Prototype pattern**:
    - 指原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象，无需知道如何创建的细节
    - 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个发动创建的对象通过请求原型对象拷贝他们自己来实现创建，如：对象.clone()
    - 对象深拷贝
    - [代码](./prototype)

- **建造者模式 Builder Pattern**：
- 介绍：
    - 建造者模式：又称生成器模式，是一种对象构建模式。将复杂的对象构建过程抽象出来，使这个抽象过程的不同实现方法可以构建出不同表现（属性）的对象
    - 构造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节
- 建造者模式的四个角色：
    - Product（产品角色）：一个具体的产品对象
    - Builder（抽象建造者）：穿件一个Product对象的各个部件制定的接口、抽象类
    - ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件
    - Director（指挥者）：构建一个使用Builder接口的对象。他主要是用于创建一个复杂的对象。他主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程
    - [代码](./builder)


### 构建型

- **适配器 Adapter Pattern**:
    - 介绍：
        - 将某个类的接口转换成客户端期望的另一个接口标示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协调工作，别名包装器（Wrapper）
        - 通过阶乘src类，实现dst类接口，完成src->dst的适配
    - [代码](./adapter)

- **桥接模式 Bridge** ：
    - 介绍：
        - 将**实现**与**抽象**放在两个不同的类层次中，使两个层次可以独立扩展
        - 基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。
    - [代码](./bridge)

- **装饰着模式 Decorator**
    - 介绍：在不改变原有对象的基础上，动态的将新功能附加到对象上。对象功能扩展比继承更有弹性
    - [代码](./decorator)

- **组合模式 Composite Pattern** ：
    - 介绍:
        - 组合模式又叫部分整体模式，他创建了对象组的属性结构，将对象组成树状结构以表示“整体 - 部分”的层次
    - [代码](./composite)

- **外观模式 Facade** ：
    - 介绍：
        - 外观模式也叫过程模式，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个借口使得这椅子系统更加容易使用
        - 外观模式通过定义一个一致的接口，可以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心系统内部细节
    - [代码](./facade)

- **享元模式Flyweight Pattern** ：
    - 介绍：
        - 享元模式也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象
        - 通常用于解决系统的性能问题，解决重复对象的内存浪费问题。如数据库连接池，里面都是创建好的链接对象，在这些连接对象中有我们需要的则直接拿来使用，避免重新创建，如果没有则再创建
    - [代码](./flyweight)

- **代理模式 Proxy**
    - 为其他对象提供一种代理，以控制对这个对象的访问
    - [代码](./proxy)


### 行为模式性

- **模板方法模式 Template Method Pattern** ：
    - 介绍：
        - 又叫模板模式 Template Pattern，在一个抽象类公开定义了执行他的方法模板。他的子类可以按需重写方法实现，但调用将以抽象类中定义的方式进行
        - 简单说，模板方法模式定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算方法的某些特定步骤
    - [代码](./template)

- **命令模式 Command Parttern** ：
    - 介绍：
        - 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
        - 命令模式可以将发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求
    - 命令模式包含以下四个角色：
        - Receiver(接收者): 接收者执行与请求相关的操作，它具体实现对请求的业务处理
        - Invoker(调用者)：请求发送者，通过命令对象来执行请求
        - Command(抽象命令类)：一个抽象类或接口，声明了执行请求的Execute()方法，通过这些方法可以调用请求接收者的相关操作
        - ConcreteCommand(具体命令类)：具体命令类是抽象命令类的子类，实现了抽象命令类中声明的方法。在实现Execute()方法时，将调用接收者对象的相关操作(Action)
    - [代码](./command)

- **访问者模式 Visitor Pattern** ：
    - 介绍：
        - 封装一些作用域某中数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的操作
        - 主要将数据结构与数据操作分离，解决数据与结构和操作耦合性问题
        - 访问者模式的基本工作原理：在访问的类里面加一个对外提供访问者的接口
    - 角色：
        - Visitor 是抽象访问者，为该对象结构中的ConcreteElement 的每一个类声明一个visit 操作
        - ConcreteVisitor ：是一个具体的访问值实现每个有Visitor 声明的操作，是每个操作实现的部分.
        - ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素
        - Element 定义一个accept 方法，接收一个访问者对象
        - ConcreteElement 为具体元素，实现了accept 方法
    - [代码](./visitor)

- **迭代器模式 Iterator Partter** ：
    - 介绍：
        - 如果我们的集合元素是用不同的方式实现的，有数组，还有java 的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决
        - 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构
    - 角色：
        - Iterator ： 迭代器接口，是系统提供，含义hasNext, next, remove
        - ConcreteIterator : 具体的迭代器类，管理迭代
        - Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦
        - ConcreteAggreage : 具体的聚合持有对象集合， 并提供一个方法，返回一个迭代器， 该迭代器可以正确遍历集合
        - Client :客户端， 通过Iterator 和Aggregate 依赖子类
    - [代码](./iterator)

- **观察者模式  Observer** ：
    - 介绍：
        - 对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer 变化
        - 观察者模式简单一句话说就是当特定事件出现时，一个对象实例把事件发布到对应的观察者实例上执行相应的更新操作。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

    - 角色：
        - 目标（Subject）: 目标知道它的观察者。可以有任意多个观察者观察同一个目标。 提供注册和删除观察者对象的接口
        - 具体目标（ConcreteSubject）:  将有关状态存入各ConcreteObserver对象
        - 观察者(Observer):  为那些在目标发生改变时需获得通知的对象定义一个更新接口。当它的状态发生改变时, 向它的各个观察者发出通知
        - 具体观察者(ConcreteObserver):   维护一个指向ConcreteSubject对象的引用。存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口以使自身状态与目标的状态保持一致
    - [代码](./obrserver)

- **中介者模式 Mediator Pattern** ：
    - 介绍：
        - 中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
        - 中介者模式属于行为型模式，使代码易于维护
        - 比如MVC 模式，C（Controller 控制器）是M（Model 模型）和V（View 视图）的中介者，在前后端交互时起到了中间人的作用
    - 角色
        - Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口
        - Colleague 是抽象同事类
        - ConcreteMediator 具体的中介者对象, 实现抽象方法, 他需要知道所有的具体的同事类,即以一个集合来管理HashMap,并接受某个同事对象消息，完成相应的任务
        - ConcreteColleague 具体的同事类，会有很多, 每个同事只知道自己的行为， 而不了解其他同事类的行为(方法)，但是他们都依赖中介者对象
    - [代码](./mediator)

- **备忘录模式 Memento Pattern** ：
    - 介绍
        - 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态
    - 角色：
        - originator : 对象(需要保存状态的对象)
        - Memento ： 备忘录对象,负责保存好记录，即Originator 内部状态
        - Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效率
        - 说明：如果希望保存多个originator 对象的不同时间的状态，也可以，只需要要HashMap <String, 集合>
    - [代码](./memento)

- **解释器模式 Interpreter Pattern** ：
    - 介绍：
        - 在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器
        - 解释器模式（Interpreter Pattern）：是指给定一个语言(表达式)，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)
        - 应用场景
            - 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
            - 一些重复出现的问题可以用一种简单的语言来表达一个简单语法需要解释的场景
            - 这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等
    - 角色：
        - Context: 是环境角色,含有解释器之外的全局信息.
        - AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所共享
        - TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作
        - NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.
        - 说明： 输入Context he TerminalExpression 信息通过Client 输入即可
    - [代码](./interpreter)

- **状态模式 State Pattern** ：
    - 介绍：
        - 状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换
        - 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类
        - 入口类包含子类的接口引用
        - 状态模式的关键是各个状态子类必须知道下一个状态是什么，且要把逻辑判断转移到各个状态子类中，客户端不需要了解状态迁移的顺序
    - 角色：
        - Context 类为环境角色, 用于维护State 实例,这个实例定义当前状态
        - State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为
        - ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为
    - [代码](./state)

- **策略者模式 Strategy Pattern** :
    - 介绍：
        - 策略模式（Strategy Pattern）中，定义算法族（策略组），分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
        - 这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）
        - 它定义了算法家族，分别封装起来，让它们可以相互替换，此模式让算法的变化，不会影响到使用算法的客户
    - [代码](./strategy)

- **职责链模式 Chain of Responsibility Pattern** ：
    - 介绍：
        - 职责链模式（Chain of Responsibility Pattern）, 又叫责任链模式，为请求创建了一个接收者对象的链。这种模式对请求的发送者和接收者进行解耦
        - 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推
        - 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
        - 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
    - 角色：
        - Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler
        - ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处理者), 如果可以处理当前请求，则处理，否则就将该请求交个后继者去处理，从而形成一个职责链
        - Request ， 含义很多属性，表示一个请求
    - [代码](./chain_of_responsibility)



### 参考
- https://github.com/sevenelevenlee/go-patterns
- https://github.com/senghoo/golang-design-pattern
- https://www.kancloud.cn/liupengjie/go/570096
- https://www.selinux.tech/designpattern/behavioral-pattern/state-pattern
